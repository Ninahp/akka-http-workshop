<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Akka HTTP Workshop</title>

    <meta name="description" content="Crash Course about Akka HTTP">
    <meta name="author" content="Josep Prat">
    <link rel="icon" href="images/favicon.ico">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );

    </script>
    <style>

    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
            <script type="text/template">
                # Akka HTTP

                ## Workshop about Akka HTTP
                * * *
                ###### 24/04/2017 - Josep Prat - [@jlprat](https://github.com/jlprat)
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Contents
                - Introduction
                - Hands On with Demos
                - Code Together
                - Wrap Up
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Contents
                - Introduction
                    - What is it?
                    - Word about Streams and Actors
                    - Golden Rules
                    - Hello World!
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Contents
                - Hands On with Demos
                    - Understanding the Model
                    - Routes and Directives
                    - Path Matchers
                    - Consuming HTTP
                    - Deal with Rejections
                    - Handling Exceptions
                    - Dealing with blocking
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Contents
                - Code Together
                    - Book Store App
                - Wrap Up
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## What is Akka HTTP?

                - Toolkit rather than a framework
                - Not (much) opinionated
                - Producer and Consumer HTTP Services
                - Not a Web framework
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## What is Akka HTTP?

                Used to be a module of [Akka](http://akka.io/), now it lives under its own [repository](https://github.com/akka/akka-http).
                It can be seen as the successor of [Spray](http://spray.io/).

                Interestingly, Akka HTTP is owned by the community and not only by the Akka Core Team, see [Akka HTTP Team](https://github.com/akka/akka-meta/issues/27).
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Useful Links

                [Github](https://github.com/akka/akka-http)

                [Documentation](http://doc.akka.io/docs/akka-http/10.0.5/index.html)

                [Gitter Room](https://gitter.im/akka/akka/)

                [User Group](https://groups.google.com/forum/#!forum/akka-user)

            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Philosophy

                Akka HTTP is build on top of Akka Streams, which rely on Akka actors. For this reason, one must follow
                the same rules as in Akka, never block.

                An HTTP server it's just a byte stream sourcing from a `Request` and sinking to a `Response`.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Word about Actors

                - Message-based
                - "Single-threaded"
                - Non-blocking
                - General purpose
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Word about Streams

                - Built on top of Actors
                - Unbounded data
                - Source -> Flow -> Sink
                - Back pressure
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Golden Rules

                - Never block
                - Never block
                - Never block
                - If you must, block in another Thread Pool
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Hello World!

                ```
                new HttpApp {
                  override protected def route: Route = path("hello") {
                    complete("world!")
                  }
                }.startServer("localhost", 9000)
                ```
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Hands On with Demos
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Understanding the Model

                ### HttpRequest:
                - Method
                - Uri
                - Headers
                - Entity
                - Protocol
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Understanding the Model

                ### HttpResponse:
                - Status Code
                - Headers
                - Entity
                - Protocol
            </script>
        </section>
        <section>
            <section data-markdown>
                <script type="text/template">
                    ## Understanding the Model

                    ### Entity:
                    - Data Bytes
                    - Content Type
                    - Content Length (if known)

                    Due to the streaming nature of Akka HTTP, there are different kinds of Entities.
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ## Understanding the Model
                    - Strict
                    - All bytes in memory
                    - Entity is small
                    - Default
                    - Streamed
                    - Data comes from Stream and length is known
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ## Understanding the Model
                    - Chunked
                    - Streamed as chunks
                    - Data comes in chunks from Stream and length is unkown
                    - CloseDelimited
                    - Streamed implicitly delimited by closing the connection
                    - Use for legacy systems
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ## Understanding the Model
                    - IndefiniteLength
                    - Streamed
                    - To use in `Multipart.Bodypart` and unknown length
                </script>
            </section>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Routes and Directives

                Routes are the central part of the Routing DSL, they process Requests and produce Responses (any kind of Responses).
                The `Route` type is an alias for `RequestContext => Future[RouteResult]`.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Routes and Directives

                Directives are the building blocks for creating Routes. They wrap the functionality of its inner route and
                apply some transformations on the `Request` or the `Response`.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Routes and Directives

                Types of Directives:
                - Transforming: They modify the request before passing it to its inner route
                - Filtering: They only pass requests that satisfy certain conditions and reject the others
                - Extracting: They provide some value to its inner route or reject otherwise
                - Completing: They complete a request (successfully or not)
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Composing Directives 101

                - Nesting
                - Side-by-side (`Route.concat` or `~` || `orElse` or `RouteDirectives.route`)
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Hands On!

                [Directives By Trait:Scala](http://doc.akka.io/docs/akka-http/current/scala/http/routing-dsl/directives/by-trait.html)

                [Directives By Trait:Java](http://doc.akka.io/docs/akka-http/current/java/http/routing-dsl/directives/by-trait.html)
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Path Matchers

                Path directives can be used to match against simple strings, or complex matchers that will extract the matched value.
                Useful ones:
                - `Segment`
                - `IntNumber`, `LongNumber`...
                - `PathEnd`
                - "foo" / "bar" (obviously only in Scala)
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Hands on!
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Consuming HTTP

                Akka HTTP comes also with a stream-first client to consume HTTP based services. The easiest (for me) mode to use the client
                is the `Future` based one. It turns an `HttpRequest` into a `Future[HttpResponse]`.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Consuming HTTP

                Example
                ```
                implicit val system = ActorSystem()
                implicit val materializer = ActorMaterializer()

                val responseFuture: Future[HttpResponse] =
                  Http().singleRequest(HttpRequest(uri = "http://akka.io"))
                ```
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Deal with Rejections

                When a route can't be handled, a rejection is produced. This doesn't necessarily mean the request will be unhandled,
                Akka HTTP will try with the next route.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Deal with Rejections

                ```
                val route = path("foo") {
                  get {
                    complete("get foo")
                  } ~
                  post {
                    complete("post foo")
                  }
                }
                ```
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Personalizing Rejections

                In the case you want to handle specific rejections in a different way, one just needs to create its own
                `RejectionHandler`. There is a default `RejectionHandler` that handles all Akka HTTP rejections (with
                conventional defaults).
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Handling Exceptions

                Sometimes your business code encounters some unexpected problems and must throw an Exception. Akka HTTP has the
                possibility to handle any exception occurred while processing a route, one just needs to create its own
                `ExceptionHandler`.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Hands on!
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Dealing with Blocking

                Blocking operations are really bad, especially when using Akka HTTP (or any other Akka library) because they block
                the same `Dispatcher` that is used to process the incoming requests. This means, your blocking code can
                bring down your whole Server.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Dealing with Blocking

                But, what to do when blocking is necessary? You need to provide a dedicated `Dispatcher` for such blocking
                calls and wrap then inside a `Future` (that uses the mentioned `Dispatcher`). This way, the main `Dispatcher`
                is always ready to handle the incoming requests.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Hands on!
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Book Store App

                Let's build a tiny simplistic Book Store.
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                ## Wrap Up

                - Not a web framework
                - Never block
                - Ideal for Streaming
                - Natural Actor integration
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Questions?
            </script>
        </section>
        <section data-markdown>
            <script type="text/template">
                # Thank you!
                * * *
                ###### 24/04/2017 - Josep Prat - [@jlprat](https://github.com/jlprat)
            </script>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                slideNumber: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

</script>
</body>
</html>
